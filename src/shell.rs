use crate::cli::cli_data::InitShell;
use std::path::PathBuf;

pub struct ShellOpts {
    pub app_path: String,
    pub data_dir: String,
    pub alias_file_path: String,
}

impl ShellOpts {
    pub fn new() -> Self {
        let app_path = std::env::current_exe()
            .unwrap_or_else(|_| PathBuf::from("app"))
            .to_string_lossy()
            .to_string();
        
        let data_dir = crate::database::persistence::get_data_directory()
            .unwrap_or_else(|_| PathBuf::from("/tmp/app"))
            .to_string_lossy()
            .to_string();
        
        let alias_file_path = crate::database::persistence::load_config()
            .and_then(|cfg| cfg.alias_file_paths.first().cloned())
            .unwrap_or_else(|| "/home/fuckotheclown/repos/projects/app/store.aliases".to_string());
        
        Self {
            app_path,
            data_dir,
            alias_file_path,
        }
    }
}

pub fn render_shell_init(shell: InitShell, opts: &ShellOpts) -> String {
    match shell {
        InitShell::Bash => render_bash(opts),
        InitShell::Zsh => render_zsh(opts),
        InitShell::Fish => render_fish(opts),
        InitShell::Posix => render_posix(opts),
    }
}

fn render_bash(opts: &ShellOpts) -> String {
    format!(
        r#"# App shell integration for bash
# This file is automatically generated by 'app init bash'

# Set up data directory
export _APP_DATA_DIR="{data_dir}"

# Set up alias file path
export _APP_ALIAS_FILE="{alias_file}"

# Function to track commands
_app_track_command() {{
    local cmd="$1"
    if [ -n "$cmd" ] && [ "$cmd" != "$_APP_LAST_CMD" ]; then
        {app_path} custom "$cmd" >/dev/null 2>&1
        export _APP_LAST_CMD="$cmd"
    fi
}}

# Set up precmd hook to track commands
_app_precmd() {{
    local cmd="$(fc -ln -1 2>/dev/null | sed 's/^[[:space:]]*//')"
    _app_track_command "$cmd"
}}

# Add precmd to PROMPT_COMMAND if not already present
if [[ ! "$PROMPT_COMMAND" =~ "_app_precmd" ]]; then
    if [ -n "$PROMPT_COMMAND" ]; then
        export PROMPT_COMMAND="_app_precmd; $PROMPT_COMMAND"
    else
        export PROMPT_COMMAND="_app_precmd"
    fi
fi

# Source personal aliases if they exist
if [ -f "$HOME/.bashrc-personal" ]; then
    source "$HOME/.bashrc-personal"
fi

# Source app aliases if they exist
if [ -f "$_APP_ALIAS_FILE" ]; then
    source "$_APP_ALIAS_FILE"
fi"#,
        app_path = opts.app_path,
        data_dir = opts.data_dir,
        alias_file = opts.alias_file_path
    )
}

fn render_zsh(opts: &ShellOpts) -> String {
    format!(
        r#"# App shell integration for zsh
# This file is automatically generated by 'app init zsh'

# Set up data directory
export _APP_DATA_DIR="{data_dir}"

# Set up alias file path
export _APP_ALIAS_FILE="{alias_file}"

# Function to track commands
_app_track_command() {{
    local cmd="$1"
    if [ -n "$cmd" ] && [ "$cmd" != "$_APP_LAST_CMD" ]; then
        {app_path} custom "$cmd" >/dev/null 2>&1
        export _APP_LAST_CMD="$cmd"
    fi
}}

# Set up precmd hook to track commands
autoload -U add-zsh-hook
add-zsh-hook precmd _app_precmd

_app_precmd() {{
    local cmd="$(fc -ln -1 2>/dev/null | sed 's/^[[:space:]]*//')"
    _app_track_command "$cmd"
}}

# Source personal aliases if they exist
if [ -f "$HOME/.zshrc-personal" ]; then
    source "$HOME/.zshrc-personal"
fi

# Source app aliases if they exist
if [ -f "$_APP_ALIAS_FILE" ]; then
    source "$_APP_ALIAS_FILE"
fi"#,
        app_path = opts.app_path,
        data_dir = opts.data_dir,
        alias_file = opts.alias_file_path
    )
}

fn render_fish(opts: &ShellOpts) -> String {
    format!(
        r#"# App shell integration for fish
# This file is automatically generated by 'app init fish'

# Set up data directory
set -g _APP_DATA_DIR "{data_dir}"

# Set up alias file path
set -g _APP_ALIAS_FILE "{alias_file}"

# Function to track commands
function _app_track_command
    set -l cmd $argv[1]
    if test -n "$cmd"; and test "$cmd" != "$_APP_LAST_CMD"
        {app_path} custom "$cmd" >/dev/null 2>&1
        set -g _APP_LAST_CMD "$cmd"
    end
end

# Set up fish_prompt hook to track commands
function fish_prompt
    set -l cmd (history | head -n1 | sed 's/^[[:space:]]*//')
    _app_track_command "$cmd"
    # Call the original fish_prompt if it exists
    if functions -q fish_prompt_original
        fish_prompt_original
    else
        echo -n '$ '
    end
end

# Source personal aliases if they exist
if test -f "$HOME/.config/fish/config-personal.fish"
    source "$HOME/.config/fish/config-personal.fish"
end

# Source app aliases if they exist
if test -f "$_APP_ALIAS_FILE"
    source "$_APP_ALIAS_FILE"
end"#,
        app_path = opts.app_path,
        data_dir = opts.data_dir,
        alias_file = opts.alias_file_path
    )
}

fn render_posix(opts: &ShellOpts) -> String {
    format!(
        r#"# App shell integration for POSIX shells
# This file is automatically generated by 'app init posix'

# Set up data directory
export _APP_DATA_DIR="{data_dir}"

# Set up alias file path
export _APP_ALIAS_FILE="{alias_file}"

# Function to track commands
_app_track_command() {{
    cmd="$1"
    if [ -n "$cmd" ] && [ "$cmd" != "$_APP_LAST_CMD" ]; then
        {app_path} custom "$cmd" >/dev/null 2>&1
        export _APP_LAST_CMD="$cmd"
    fi
}}

# Set up PS1 hook to track commands (basic implementation)
_app_ps1() {{
    local cmd="$(fc -ln -1 2>/dev/null | sed 's/^[[:space:]]*//')"
    _app_track_command "$cmd"
    echo '$ '
}}

# Set PS1 to use our hook
export PS1='$(_app_ps1)'

# Source personal aliases if they exist
if [ -f "$HOME/.profile-personal" ]; then
    . "$HOME/.profile-personal"
fi

# Source app aliases if they exist
if [ -f "$_APP_ALIAS_FILE" ]; then
    . "$_APP_ALIAS_FILE"
fi"#,
        app_path = opts.app_path,
        data_dir = opts.data_dir,
        alias_file = opts.alias_file_path
    )
} 